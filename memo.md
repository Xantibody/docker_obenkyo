20231229

- ざっくり見た感じ、JavaプロジェクトのDockerfileとcompose記述がないからそこを治す？
- Javaの準備は終わったが、起動方法が上手く見つけられなかったからモーちょいintelliJを調べる
- あとこれ普通に立ち上げたら動くのか聞いてみる

20231230

- IntelliJでSpringプロジェクトをインポートする場合は、build.gradleを指定しないといけないよ
- 現状の課題はフロントのcompse記述（必要性要調査）、外部接続確認、バックエンドのDockerfile、dockerのDBとの接続設定
- SpringのDcokerfile作成はちょっとやったから、そっから手を付けてみる


20240103
- 今日の作業として彼はworkメモに作業工程の予想を記述した
- 今後の彼の予定は作業工程の切り分けを部分的に調査、実装する
- 具体的には、バックエンドのSpringプロジェクトで起動するDockerfileをJavaのバージョンに気を付けながら作成する


20240104
- 彼が行おうとしていたDockerfile作成には行きつかず、ベースイメージの調査とhadolint導入で終わった
- 彼が失敗した原因としてはDockerへの知識が浅かったことと、Dockerfileの性的監視ツールの導入を検討していなかったこと
- Dcokerfile内にFROMは記述してあり、次の目標としてCOPYやポート番号などを指定して起動までを行う

20240105
- 彼が今日学習したことはDockerfileのrootless構成についての理解、DockerfileのGO言語の使用、TSのfetchの記述からバックエンドのportの確認
- 彼が想定している進捗ではないが、原因としては一つ一つの理解をしているため、勉学という観点では正しい
- 彼の明日の今後の指針として学習速度を余裕をもって見積もることと、明日はjarfileの回答次第で記述法を決めることを行ってもらう

20240107
- 彼が今回躓いたのは、COPYしたプロジェクト内のgradlewがCRLFでLinux内で実行できなかったこと
- Dockerfileが完成すると、compose記述を調べてそのまま実行までは成功している
- 次の課題として、localhostにつなぎに行ってしまっているbackendをDBと繋ぐための方法を考えると思われる

20240108
- 今日の彼は個々のDockerにてDBとバックエンドの接続を行った
- composeのport記述で前半がクライアントであることを間違えていた（8080:8081と記述してlinuxサーバに存在しないportを指定していた）
- 次の彼の課題は、フロントエンドをcompose.ymlに記述、バックエンドと接続する